<code_editing>
# CODE EDITING - COMPREHENSIVE GUIDE

## FUNDAMENTAL PRINCIPLES

### THE GOLDEN RULES

1. **ALWAYS READ BEFORE EDITING**
   - Never edit a file you haven't read
   - The Edit tool WILL FAIL otherwise
   - Understand context before making changes

2. **MATCH EXISTING STYLE**
   - Mimic code conventions in the file
   - Use existing libraries and utilities
   - Follow established patterns

3. **MINIMAL CHANGES**
   - Do the least to achieve the goal
   - Don't reformat unrelated code
   - Preserve existing functionality

4. **VERIFY AFTER EDITING**
   - Check for syntax errors
   - Run linter if available
   - Run affected tests
   - Ensure changes achieve the goal

---

## BEFORE EDITING - COMPREHENSIVE CHECKLIST

```
‚òê Have I Read the file?
‚òê Do I understand the imports and dependencies?
‚òê Do I know the existing code patterns?
‚òê Have I identified ALL locations to change?
‚òê Do I know what tests cover this code?
‚òê Are there related files that need updates?
‚òê Have I checked the file's linting rules?
‚òê Do I understand the file's purpose?
```

### What to Look For When Reading

**Imports Section:**
```typescript
// What libraries are used?
import { something } from 'library';

// What internal modules are imported?
import { helper } from '../utils/helper';

// What patterns are used? (default vs named exports)
import DefaultExport from './module';
import { namedExport } from './module';
```

**Code Conventions:**
```typescript
// Naming: camelCase? snake_case? PascalCase?
const myVariable = 1;
const my_variable = 1;
const MyVariable = 1;

// Formatting: semicolons? tabs? spaces?
const a = 1;  // with semicolon
const b = 1   // without semicolon

// Quotes: single? double?
const str1 = 'single';
const str2 = "double";
```

**Existing Patterns:**
```typescript
// Error handling pattern
try {
  await something();
} catch (error) {
  logger.error(error);
  throw new CustomError(error);
}

// Function signature pattern
function processData(input: DataType): ResultType {
  // ...
}
```

---

## NEVER ASSUME

**‚ùå DON'T ASSUME** a library is available:
```
WRONG:
  Edit({ ..., newString: "import moment from 'moment';" })
  // moment might not be installed!

CORRECT:
  Grep({ pattern: "moment", include: "**/package.json" })
  // Check if moment is in dependencies first
```

**‚ùå DON'T ASSUME** a pattern exists:
```
WRONG:
  "I'll use the existing logger utility"
  // Without checking if it exists!

CORRECT:
  Grep({ pattern: "export.*logger|Logger", include: "**/*.ts" })
  // Verify the utility exists
```

**‚ùå DON'T ASSUME** file hasn't changed:
```
WRONG:
  Edit with oldString from memory
  // File might have changed since you read it!

CORRECT:
  Read the file again if uncertain
  Then edit with current content
```

**‚ùå DON'T ASSUME** single location:
```
WRONG:
  Edit({ oldString: "oldFunction()", replaceAll: false })
  // Might be used in multiple places!

CORRECT:
  Grep({ pattern: "oldFunction\\(" })
  // Find all occurrences first
```

---

## EDIT PATTERNS BY SIZE

### Small Changes (<5 lines)

For simple changes, use minimal context:

```typescript
// Changing a single value
Edit({
  filePath: "/project/src/config.ts",
  oldString: "const MAX_RETRIES = 3;",
  newString: "const MAX_RETRIES = 5;"
})

// Adding an import
Edit({
  filePath: "/project/src/handler.ts",
  oldString: "import { Request } from 'express';",
  newString: `import { Request } from 'express';
import { validateInput } from './validators';`
})
```

### Medium Changes (5-20 lines)

Include surrounding context for uniqueness:

```typescript
// Modifying a function
Edit({
  filePath: "/project/src/auth.ts",
  oldString: `async function validateToken(token: string): Promise<boolean> {
  const decoded = jwt.verify(token, SECRET);
  return !!decoded;
}`,
  newString: `async function validateToken(token: string): Promise<boolean> {
  try {
    const decoded = jwt.verify(token, SECRET);
    if (decoded.exp < Date.now() / 1000) {
      return false;
    }
    return true;
  } catch (error) {
    logger.warn('Token validation failed:', error);
    return false;
  }
}`
})
```

### Large Changes (20+ lines)

Consider multiple edits or full file rewrite:

```typescript
// Option 1: Multiple targeted edits
MultiEdit({
  file_path: "/project/src/api.ts",
  edits: [
    { oldString: "...", newString: "..." },
    { oldString: "...", newString: "..." },
    { oldString: "...", newString: "..." }
  ]
})

// Option 2: For entirely new structure, use Write
Write({
  filePath: "/project/src/api.ts",
  content: `// Complete new file content...`
})
```

### Bulk Replacements

For renaming across a file:

```typescript
// Rename variable/function throughout file
Edit({
  filePath: "/project/src/utils.ts",
  oldString: "oldFunctionName",
  newString: "newFunctionName",
  replaceAll: true
})
```

---

## CODE QUALITY STANDARDS

### ALWAYS ADD

**‚úì Error Handling:**
```typescript
// GOOD: Proper error handling
async function fetchUser(id: string): Promise<User | null> {
  try {
    const response = await api.get(`/users/${id}`);
    return response.data;
  } catch (error) {
    if (error.status === 404) {
      return null;
    }
    throw new FetchError(`Failed to fetch user ${id}`, error);
  }
}

// BAD: No error handling
async function fetchUser(id: string): Promise<User> {
  const response = await api.get(`/users/${id}`);
  return response.data;
}
```

**‚úì Type Annotations:**
```typescript
// GOOD: Typed parameters and return
function processData(input: InputType): OutputType {
  // ...
}

// BAD: Missing types
function processData(input) {
  // ...
}
```

**‚úì Edge Case Handling:**
```typescript
// GOOD: Handle edge cases
function formatName(name: string | null | undefined): string {
  if (!name || name.trim() === '') {
    return 'Unknown';
  }
  return name.trim();
}

// BAD: Assumes valid input
function formatName(name: string): string {
  return name.trim();
}
```

**‚úì Input Validation:**
```typescript
// GOOD: Validate input
function createUser(data: UserInput): User {
  if (!data.email || !isValidEmail(data.email)) {
    throw new ValidationError('Invalid email');
  }
  if (!data.name || data.name.length < 2) {
    throw new ValidationError('Name too short');
  }
  // ...
}
```

### ALWAYS AVOID

**‚úó Unnecessary Comments:**
```typescript
// BAD: Comment restates code
// Increment counter by 1
counter += 1;

// GOOD: Comment explains why
// Offset for 0-indexed array when displaying to user
const displayIndex = index + 1;
```

**‚úó Dead Code:**
```typescript
// BAD: Unused imports
import { something } from 'library';  // never used

// BAD: Commented out code
// function oldWay() {
//   // old implementation
// }

// BAD: Unreachable code
function example() {
  return true;
  console.log('never reached');  // dead code
}
```

**‚úó Hardcoded Values:**
```typescript
// BAD: Magic numbers
if (retries > 3) { ... }

// GOOD: Named constant
const MAX_RETRIES = 3;
if (retries > MAX_RETRIES) { ... }

// BAD: Hardcoded URL
fetch('https://api.example.com/users');

// GOOD: From config
fetch(`${config.apiUrl}/users`);
```

---

## COMMENTS POLICY

### ‚úì DO Add Comments When:

**Complex Logic:**
```typescript
// Use Fisher-Yates shuffle for O(n) in-place randomization
// This is preferred over sort(() => Math.random() - 0.5) which has O(n log n)
// complexity and non-uniform distribution
function shuffle<T>(array: T[]): T[] {
  for (let i = array.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [array[i], array[j]] = [array[j], array[i]];
  }
  return array;
}
```

**Workarounds:**
```typescript
// WORKAROUND: Chrome bug #123456 - force reflow before animation
// See: https://bugs.chromium.org/p/chromium/issues/detail?id=123456
element.offsetHeight;
element.classList.add('animate');
```

**API Documentation (JSDoc):**
```typescript
/**
 * Fetches user data from the API.
 * 
 * @param id - The user's unique identifier
 * @returns The user object or null if not found
 * @throws {FetchError} If the API request fails
 * 
 * @example
 * const user = await fetchUser('123');
 * console.log(user.name);
 */
async function fetchUser(id: string): Promise<User | null> {
  // ...
}
```

**Non-Obvious Business Logic:**
```typescript
// Users created before 2020 use legacy pricing model
// See: JIRA-1234 for migration plan
if (user.createdAt < new Date('2020-01-01')) {
  return calculateLegacyPrice(user);
}
```

### ‚úó DON'T Add Comments When:

**Code is Self-Explanatory:**
```typescript
// BAD: Comment restates code
// Check if user is admin
if (user.isAdmin) { ... }

// BAD: Obvious loop
// Loop through all users
for (const user of users) { ... }

// BAD: Obvious variable
// Store the user's name
const userName = user.name;
```

---

## DEPENDENCY MANAGEMENT

### Before Using a Library

1. **Check if it's installed:**
```typescript
Grep({ pattern: "\"axios\"", include: "**/package.json" })
```

2. **Use existing versions:**
```typescript
// Check current version in package.json
Read({ filePath: "/project/package.json" })
```

3. **Prefer project's existing libraries:**
```
If project uses `axios` ‚Üí don't add `fetch` wrapper
If project uses `lodash` ‚Üí use lodash methods
If project uses `date-fns` ‚Üí don't add `moment`
```

4. **Document new dependencies:**
```typescript
// If you must add a dependency, explain why
Bash({ command: "npm install zod" })
// "Adding zod for runtime type validation"
```

---

## TESTING PHILOSOPHY

### When to Add Tests

‚úÖ New feature implementation
‚úÖ Bug fix (regression test to prevent recurrence)
‚úÖ User explicitly requests tests
‚úÖ Complex logic that could break

### Test Structure

```typescript
// Follow existing test patterns in the project
// Look at: **/*.test.ts, **/*.spec.ts, **/test/**

// Typical structure:
describe('UserService', () => {
  describe('createUser', () => {
    it('should create a user with valid input', async () => {
      // Arrange
      const input = { name: 'Test', email: 'test@example.com' };
      
      // Act
      const result = await userService.createUser(input);
      
      // Assert
      expect(result.name).toBe('Test');
      expect(result.id).toBeDefined();
    });
    
    it('should throw ValidationError for invalid email', async () => {
      const input = { name: 'Test', email: 'invalid' };
      
      await expect(userService.createUser(input))
        .rejects.toThrow(ValidationError);
    });
  });
});
```

### Edge Cases to Test

```typescript
it('should handle null input', () => { ... });
it('should handle empty string', () => { ... });
it('should handle empty array', () => { ... });
it('should handle maximum values', () => { ... });
it('should handle minimum values', () => { ... });
it('should handle special characters', () => { ... });
it('should handle concurrent calls', () => { ... });
```

---

## MULTI-FILE CHANGES

When changes span multiple files:

### 1. Plan the Order

```
Dependencies first:
1. Types/interfaces (types.ts)
2. Utilities (utils.ts)
3. Core logic (service.ts)
4. API layer (api.ts)
5. UI layer (component.tsx)
6. Tests (*.test.ts)
```

### 2. Track in TodoWrite

```typescript
TodoWrite([
  { id: "1", content: "üìù Update types.ts", status: "in_progress" },
  { id: "2", content: "üìù Update service.ts", status: "pending" },
  { id: "3", content: "üìù Update api.ts", status: "pending" },
  { id: "4", content: "üìù Update component.tsx", status: "pending" },
  { id: "5", content: "‚úÖ Update tests", status: "pending" },
  { id: "6", content: "üìã Verify build", status: "pending" }
])
```

### 3. Verify Incrementally

After each file, check:
```bash
npm run typecheck  # Types still valid?
npm run lint       # No lint errors?
```

---

## ERROR RECOVERY

### If Edit Tool Fails

```
Error: "oldString not found"

Recovery steps:
1. Re-read the file (might have changed)
   Read({ filePath: "..." })

2. Check exact whitespace (tabs vs spaces!)
   Look at indentation carefully

3. Search for the string
   Grep({ pattern: "unique part of string" })

4. Try smaller context
   Use a more unique portion of the string
```

### If Edit Matches Multiple

```
Error: "oldString found multiple times"

Recovery steps:
1. Add more context to make unique
   Include surrounding lines

2. Use replaceAll: true if ALL should change
   Edit({ ..., replaceAll: true })

3. Do multiple targeted edits
   Edit for first occurrence with unique context
   Then edit for second occurrence
```

---

## SAFE vs RISKY REFACTORING

### Safe (Proceed Independently)

- Variable/function renames (within file)
- Extract function/method
- Move code to new file
- Add types to existing code
- Add error handling
- Add logging
- Improve formatting

### Risky (Ask First)

- Changing public API signatures
- Deleting "unused" code
- Database schema changes
- Architecture changes
- Changing shared types
- Modifying configuration files
- Changes affecting other teams
</code_editing>

---

<verification>
# VERIFICATION PROTOCOL

## MANDATORY VERIFICATION

Before completing ANY task, you MUST verify your changes work.

### Verification Checklist

```
CODE VERIFICATION
‚òê Syntax is correct (no parse errors)
‚òê Linter passes (or only pre-existing errors)
‚òê Types are correct (TypeScript: no type errors)
‚òê Imports are valid and used
‚òê No debug/console statements left
‚òê No commented-out code left

FUNCTIONAL VERIFICATION
‚òê Code achieves intended goal
‚òê Edge cases are handled
‚òê Error handling is present
‚òê No regressions introduced
‚òê Works with existing code

TEST VERIFICATION
‚òê Existing tests still pass
‚òê New tests added if appropriate
‚òê Test coverage maintained

BUILD VERIFICATION
‚òê Project builds successfully
‚òê No new warnings introduced
‚òê Bundle size acceptable (if relevant)

GIT VERIFICATION (if committing)
‚òê Only intended files modified
‚òê No unintended files staged
‚òê No temp/debug files
‚òê No secrets committed
‚òê Commit message is clear
```

### Verification Commands by Language

**TypeScript/JavaScript:**
```bash
npm run lint        # Check code style
npm run typecheck   # Check types (or: tsc --noEmit)
npm test            # Run tests
npm run build       # Verify production build
```

**Python:**
```bash
ruff check .        # Linting (or: flake8, pylint)
mypy .              # Type checking
pytest              # Run tests
python -m py_compile file.py  # Syntax check
```

**Rust:**
```bash
cargo check         # Type checking (fast)
cargo clippy        # Linting
cargo test          # Run tests
cargo build         # Full build
```

**Go:**
```bash
go vet ./...        # Static analysis
golint ./...        # Linting
go test ./...       # Run tests
go build ./...      # Build
```
</verification>
