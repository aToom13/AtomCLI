<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    <title>Flappy Bird - Ultimate Edition</title>
    <style>
      @import url("https://fonts.googleapis.com/css2?family=Fredoka+One&display=swap");

      body {
        margin: 0;
        padding: 0;
        overflow: hidden;
        background-color: #333;
        font-family: "Fredoka One", cursive;
        touch-action: none;
        display: flex;
        justify-content: center;
        align-items: center;
        height: 100vh;
      }

      #game-container {
        position: relative;
        box-shadow: 0 0 50px rgba(0, 0, 0, 0.5);
        border-radius: 10px;
        overflow: hidden;
        width: 100%;
        height: 100%;
        max-width: 480px; /* Mobile-first portrait constraint */
        max-height: 800px;
      }

      canvas {
        display: block;
        width: 100%;
        height: 100%;
        background: linear-gradient(to bottom, #4ec0ca, #fff);
      }

      .ui-layer {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        pointer-events: none;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        text-align: center;
        text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
      }

      .hidden {
        display: none !important;
      }

      #start-screen,
      #game-over-screen {
        background: rgba(0, 0, 0, 0.4);
        pointer-events: auto;
        backdrop-filter: blur(2px);
        width: 100%;
        height: 100%;
      }

      h1 {
        color: #fff;
        font-size: 48px;
        margin: 0 0 20px 0;
        background: linear-gradient(to bottom, #ff9a44, #fc5c65);
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        -webkit-text-stroke: 2px #fff;
        filter: drop-shadow(0 4px 0 rgba(0, 0, 0, 0.2));
        animation: float 2s ease-in-out infinite;
      }

      .btn {
        background: linear-gradient(to bottom, #f6e58d, #f9ca24);
        border: 3px solid #fff;
        border-radius: 25px;
        padding: 15px 40px;
        font-family: "Fredoka One", cursive;
        font-size: 24px;
        color: #eb4d4b;
        cursor: pointer;
        transition:
          transform 0.1s,
          box-shadow 0.1s;
        box-shadow:
          0 6px 0 #c49c1a,
          0 10px 10px rgba(0, 0, 0, 0.2);
        pointer-events: auto;
        text-transform: uppercase;
      }

      .btn:active {
        transform: translateY(6px);
        box-shadow:
          0 0 0 #c49c1a,
          0 2px 5px rgba(0, 0, 0, 0.2);
      }

      #score-display {
        position: absolute;
        top: 10%;
        font-size: 64px;
        color: white;
        -webkit-text-stroke: 3px #000;
        pointer-events: none;
        z-index: 10;
      }

      .score-board {
        background: #f1f2f6;
        border: 4px solid #535c68;
        border-radius: 15px;
        padding: 20px;
        width: 250px;
        margin-bottom: 20px;
        box-shadow: inset 0 0 20px rgba(0, 0, 0, 0.1);
      }

      .score-item {
        display: flex;
        justify-content: space-between;
        font-size: 24px;
        color: #eb4d4b;
        margin: 10px 0;
      }

      .medal {
        font-size: 48px;
        margin-top: 10px;
      }

      @keyframes float {
        0%,
        100% {
          transform: translateY(0);
        }
        50% {
          transform: translateY(-10px);
        }
      }

      /* Flash effect for hits */
      #flash {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: white;
        opacity: 0;
        pointer-events: none;
        transition: opacity 0.1s;
        z-index: 20;
      }
    </style>
  </head>
  <body>
    <div id="game-container">
      <canvas id="gameCanvas"></canvas>

      <div id="score-display" class="hidden">0</div>
      <div id="flash"></div>

      <div id="start-screen" class="ui-layer">
        <h1>FLAPPY<br />BIRD</h1>
        <button class="btn" id="start-btn">START</button>
        <p style="color: white; margin-top: 20px; font-size: 18px">Tap, Click, or Space to Flap</p>
      </div>

      <div id="game-over-screen" class="ui-layer hidden">
        <h1>GAME OVER</h1>
        <div class="score-board">
          <div class="score-item">
            <span>SCORE</span>
            <span id="final-score">0</span>
          </div>
          <div class="score-item">
            <span>BEST</span>
            <span id="best-score">0</span>
          </div>
          <div class="medal" id="medal">ðŸ¥‡</div>
        </div>
        <button class="btn" id="restart-btn">RESTART</button>
      </div>
    </div>

    <script>
      /**
       * AUDIO SYSTEM - Synthetic sound generation using Web Audio API
       * No external files needed.
       */
      class AudioController {
        constructor() {
          this.ctx = new (window.AudioContext || window.webkitAudioContext)()
          this.masterGain = this.ctx.createGain()
          this.masterGain.gain.value = 0.3 // Global volume
          this.masterGain.connect(this.ctx.destination)
          this.enabled = true
        }

        playJump() {
          if (!this.enabled) return
          if (this.ctx.state === "suspended") this.ctx.resume()

          const osc = this.ctx.createOscillator()
          const gain = this.ctx.createGain()

          osc.type = "sine"
          osc.frequency.setValueAtTime(300, this.ctx.currentTime)
          osc.frequency.linearRampToValueAtTime(600, this.ctx.currentTime + 0.1)

          gain.gain.setValueAtTime(0.5, this.ctx.currentTime)
          gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.1)

          osc.connect(gain)
          gain.connect(this.masterGain)

          osc.start()
          osc.stop(this.ctx.currentTime + 0.1)
        }

        playScore() {
          if (!this.enabled) return
          const osc = this.ctx.createOscillator()
          const gain = this.ctx.createGain()

          osc.type = "square"
          osc.frequency.setValueAtTime(1000, this.ctx.currentTime)

          gain.gain.setValueAtTime(0.1, this.ctx.currentTime)
          gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.15)

          osc.connect(gain)
          gain.connect(this.masterGain)

          osc.start()
          osc.stop(this.ctx.currentTime + 0.15)
        }

        playHit() {
          if (!this.enabled) return
          const osc = this.ctx.createOscillator()
          const gain = this.ctx.createGain()

          osc.type = "sawtooth"
          osc.frequency.setValueAtTime(150, this.ctx.currentTime)
          osc.frequency.exponentialRampToValueAtTime(50, this.ctx.currentTime + 0.1)

          gain.gain.setValueAtTime(0.5, this.ctx.currentTime)
          gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.1)

          osc.connect(gain)
          gain.connect(this.masterGain)

          osc.start()
          osc.stop(this.ctx.currentTime + 0.1)
        }

        playDie() {
          if (!this.enabled) return
          // Hit sound followed by falling sound
          this.playHit()

          setTimeout(() => {
            const osc = this.ctx.createOscillator()
            const gain = this.ctx.createGain()

            osc.type = "triangle"
            osc.frequency.setValueAtTime(200, this.ctx.currentTime)
            osc.frequency.linearRampToValueAtTime(50, this.ctx.currentTime + 0.4)

            gain.gain.setValueAtTime(0.3, this.ctx.currentTime)
            gain.gain.linearRampToValueAtTime(0.01, this.ctx.currentTime + 0.4)

            osc.connect(gain)
            gain.connect(this.masterGain)

            osc.start()
            osc.stop(this.ctx.currentTime + 0.4)
          }, 100)
        }
      }

      /**
       * GAME ENGINE
       */
      const canvas = document.getElementById("gameCanvas")
      const ctx = canvas.getContext("2d")
      const audio = new AudioController()

      // Game State
      let frames = 0
      let score = 0
      let bestScore = localStorage.getItem("flappy_best") || 0
      let gameState = "START" // START, PLAYING, GAMEOVER
      let gameSpeed = 3

      // Resize handling
      function resize() {
        // Get parent dimensions
        const parent = canvas.parentElement
        canvas.width = parent.clientWidth
        canvas.height = parent.clientHeight
      }
      window.addEventListener("resize", resize)
      resize()

      // Input handling
      function inputAction(e) {
        if (e.type === "keydown" && e.code !== "Space") return
        if (e.type === "keydown") e.preventDefault() // Prevent scrolling

        switch (gameState) {
          case "START":
            startGame()
            break
          case "PLAYING":
            bird.flap()
            break
          case "GAMEOVER":
            // Handled by restart button
            break
        }
      }

      window.addEventListener("keydown", inputAction)
      window.addEventListener(
        "touchstart",
        (e) => {
          // Prevent double firing if touch simulates click
          if (e.target.tagName !== "BUTTON") inputAction(e)
        },
        { passive: false },
      )
      canvas.addEventListener("mousedown", inputAction)

      // UI Elements
      const startScreen = document.getElementById("start-screen")
      const gameOverScreen = document.getElementById("game-over-screen")
      const scoreDisplay = document.getElementById("score-display")
      const finalScoreEl = document.getElementById("final-score")
      const bestScoreEl = document.getElementById("best-score")
      const medalEl = document.getElementById("medal")
      const flashEl = document.getElementById("flash")

      document.getElementById("start-btn").addEventListener("click", startGame)
      document.getElementById("restart-btn").addEventListener("click", resetGame)

      function startGame() {
        gameState = "PLAYING"
        startScreen.classList.add("hidden")
        gameOverScreen.classList.add("hidden")
        scoreDisplay.classList.remove("hidden")
        scoreDisplay.innerText = score
        bird.flap()
        audio.ctx.resume()
      }

      function resetGame() {
        bird.reset()
        pipes.reset()
        background.reset()
        particles.reset()
        score = 0
        frames = 0
        gameState = "START"

        gameOverScreen.classList.add("hidden")
        startScreen.classList.remove("hidden")
        scoreDisplay.classList.add("hidden")
      }

      function gameOver() {
        gameState = "GAMEOVER"
        audio.playDie()

        // Flash effect
        flashEl.style.opacity = "0.6"
        setTimeout(() => (flashEl.style.opacity = "0"), 100)

        // Save score
        if (score > bestScore) {
          bestScore = score
          localStorage.setItem("flappy_best", bestScore)
        }

        // Update UI
        finalScoreEl.innerText = score
        bestScoreEl.innerText = bestScore

        // Determine Medal
        if (score >= 40)
          medalEl.innerText = "ðŸ¥‡" // Platinum
        else if (score >= 20)
          medalEl.innerText = "ðŸ¥‡" // Gold
        else if (score >= 10)
          medalEl.innerText = "ðŸ¥ˆ" // Silver
        else medalEl.innerText = "ðŸ¥‰" // Bronze

        setTimeout(() => {
          scoreDisplay.classList.add("hidden")
          gameOverScreen.classList.remove("hidden")
        }, 500)
      }

      /**
       * GAME OBJECTS
       */

      // Background with Parallax
      const background = {
        cloudsX: 0,
        cityX: 0,

        draw() {
          // Sky is drawn by CSS/Canvas background

          // Clouds (Slowest)
          ctx.fillStyle = "#fff"
          this.cloudsX = (this.cloudsX - gameSpeed * 0.2) % canvas.width

          // Draw 2 sets of clouds for seamless loop
          ;[this.cloudsX, this.cloudsX + canvas.width].forEach((x) => {
            ctx.globalAlpha = 0.6
            this.drawCloud(x + 50, 100, 60)
            this.drawCloud(x + 300, 150, 50)
            this.drawCloud(x + 600, 80, 70)
            ctx.globalAlpha = 1.0
          })

          // Cityscape (Medium)
          this.cityX = (this.cityX - gameSpeed * 0.5) % 400 // Pattern width 400
          const cityY = canvas.height - 100 // Above ground

          ctx.fillStyle = "#a4b0be" // Silhouette color
          for (let i = 0; i < canvas.width / 50 + 2; i++) {
            // Simple building shapes
            let h = 50 + Math.sin(i * 132) * 30
            let x = i * 50 + this.cityX
            ctx.fillRect(x, cityY - h, 52, h)

            // Windows
            ctx.fillStyle = "#dfe4ea"
            if (i % 2 === 0) ctx.fillRect(x + 10, cityY - h + 10, 10, 10)
            if (i % 3 === 0) ctx.fillRect(x + 30, cityY - h + 20, 10, 20)
            ctx.fillStyle = "#a4b0be"
          }

          // Ground (Fastest - moves with pipes)
          // Handled separately to be on top of pipes sometimes or just below
        },

        drawCloud(x, y, r) {
          ctx.beginPath()
          ctx.arc(x, y, r, 0, Math.PI * 2)
          ctx.arc(x + r * 0.7, y - r * 0.3, r * 0.8, 0, Math.PI * 2)
          ctx.arc(x - r * 0.7, y - r * 0.3, r * 0.8, 0, Math.PI * 2)
          ctx.fill()
        },

        reset() {
          this.cloudsX = 0
          this.cityX = 0
        },
      }

      const ground = {
        x: 0,
        height: 60,
        draw() {
          if (gameState !== "GAMEOVER") {
            this.x = (this.x - gameSpeed) % 20
          }

          const y = canvas.height - this.height

          // Grass top
          ctx.fillStyle = "#7bed9f"
          ctx.fillRect(0, y, canvas.width, 15)

          // Dirt body
          ctx.fillStyle = "#eccc68"
          ctx.fillRect(0, y + 15, canvas.width, this.height - 15)

          // Diagonal stripes for motion effect
          ctx.fillStyle = "#dcb857"
          for (let i = this.x - 20; i < canvas.width; i += 20) {
            ctx.beginPath()
            ctx.moveTo(i, y + 15)
            ctx.lineTo(i + 10, y + 15)
            ctx.lineTo(i - 10, canvas.height)
            ctx.lineTo(i - 20, canvas.height)
            ctx.fill()
          }

          // Top border
          ctx.fillStyle = "#555"
          ctx.fillRect(0, y, canvas.width, 2)
        },
      }

      const bird = {
        x: 50,
        y: 150,
        w: 34,
        h: 24,
        velocity: 0,
        gravity: 0.25,
        jumpStrength: 4.6,
        rotation: 0,
        frame: 0,

        draw() {
          // Physics
          if (gameState === "PLAYING" || gameState === "GAMEOVER") {
            this.velocity += this.gravity
            this.y += this.velocity

            // Rotation based on velocity
            if (this.velocity < 0) this.rotation = (-25 * Math.PI) / 180
            else {
              this.rotation += (2 * Math.PI) / 180
              if (this.rotation > (90 * Math.PI) / 180) this.rotation = (90 * Math.PI) / 180
            }
          } else {
            // Hover animation in menu
            this.y = canvas.height / 2 - 50 + Math.sin(frames * 0.05) * 5
            this.rotation = 0
          }

          // Floor collision
          if (this.y + this.h / 2 >= canvas.height - ground.height) {
            this.y = canvas.height - ground.height - this.h / 2
            if (gameState === "PLAYING") gameOver()
          }

          // Rendering
          ctx.save()
          ctx.translate(this.x, this.y)
          ctx.rotate(this.rotation)

          // Draw Bird Body
          ctx.fillStyle = "#ffeb3b" // Yellow body
          ctx.beginPath()
          ctx.ellipse(0, 0, this.w / 2, this.h / 2, 0, 0, Math.PI * 2)
          ctx.fill()
          ctx.lineWidth = 2
          ctx.strokeStyle = "#000"
          ctx.stroke()

          // Eye
          ctx.fillStyle = "#fff"
          ctx.beginPath()
          ctx.arc(6, -6, 8, 0, Math.PI * 2)
          ctx.fill()
          ctx.stroke()
          ctx.fillStyle = "#000"
          ctx.beginPath()
          ctx.arc(8, -6, 2, 0, Math.PI * 2)
          ctx.fill()

          // Beak
          ctx.fillStyle = "#ff5722"
          ctx.beginPath()
          ctx.moveTo(8, 2)
          ctx.lineTo(16, 6)
          ctx.lineTo(8, 10)
          ctx.fill()
          ctx.stroke()

          // Wing (Animated)
          const wingY = gameState === "PLAYING" && frames % 10 < 5 ? -2 : 4
          ctx.fillStyle = "#fdd835"
          ctx.beginPath()
          ctx.ellipse(-6, 2, 8, 5, 0, 0, Math.PI * 2)
          ctx.fill()
          ctx.stroke()

          ctx.restore()
        },

        flap() {
          this.velocity = -this.jumpStrength
          this.rotation = (-25 * Math.PI) / 180
          audio.playJump()
          particles.spawn(this.x, this.y + 10)
        },

        reset() {
          this.y = 150
          this.velocity = 0
          this.rotation = 0
        },
      }

      const pipes = {
        items: [],
        width: 60, // Width of pipe
        gap: 150, // Gap size
        dx: 3,
        spawnTimer: 0,

        draw() {
          if (gameState !== "PLAYING") return

          // Spawning
          if (frames % 100 === 0) {
            const minHeight = 50
            const maxHeight = canvas.height - ground.height - this.gap - minHeight
            const topHeight = Math.floor(Math.random() * (maxHeight - minHeight + 1) + minHeight)

            this.items.push({
              x: canvas.width,
              topHeight: topHeight,
              passed: false,
            })
          }

          // Drawing & Logic
          for (let i = 0; i < this.items.length; i++) {
            let p = this.items[i]
            p.x -= this.dx

            // Draw Top Pipe
            this.drawPipe(p.x, 0, p.topHeight, true)

            // Draw Bottom Pipe
            const bottomY = p.topHeight + this.gap
            const bottomH = canvas.height - ground.height - bottomY
            this.drawPipe(p.x, bottomY, bottomH, false)

            // Collision Detection
            // Simple AABB collision
            // Bird hitbox slightly smaller than visual for fairness
            const bx = bird.x - bird.w / 2 + 4
            const by = bird.y - bird.h / 2 + 4
            const bw = bird.w - 8
            const bh = bird.h - 8

            // Check columns
            if (bx + bw > p.x && bx < p.x + this.width) {
              // Check heights (hit top or hit bottom)
              if (by < p.topHeight || by + bh > bottomY) {
                gameOver()
              }
            }

            // Score counting
            if (p.x + this.width < bird.x && !p.passed) {
              score++
              p.passed = true
              scoreDisplay.innerText = score
              // Animate score pop
              scoreDisplay.style.transform = "scale(1.5)"
              setTimeout(() => (scoreDisplay.style.transform = "scale(1)"), 100)
              audio.playScore()
            }

            // Removal
            if (p.x + this.width < 0) {
              this.items.shift()
              i--
            }
          }
        },

        drawPipe(x, y, h, isTop) {
          const pipeColor = "#7bed9f"
          const pipeBorder = "#535c68"
          const highlight = "#a3f3be"

          // Body
          ctx.fillStyle = pipeColor
          ctx.fillRect(x, y, this.width, h)

          // Highlight (3D effect)
          ctx.fillStyle = highlight
          ctx.fillRect(x + 5, y, 10, h) // Left highlight
          ctx.fillRect(x + this.width - 15, y, 5, h) // Right subtle light

          // Border
          ctx.strokeStyle = pipeBorder
          ctx.lineWidth = 2
          ctx.strokeRect(x, y, this.width, h)

          // Cap
          const capH = 24
          const capY = isTop ? y + h - capH : y

          ctx.fillStyle = pipeColor
          ctx.fillRect(x - 2, capY, this.width + 4, capH)

          // Cap Highlight
          ctx.fillStyle = highlight
          ctx.fillRect(x + 5, capY, 10, capH)

          // Cap Border
          ctx.strokeRect(x - 2, capY, this.width + 4, capH)
        },

        reset() {
          this.items = []
        },
      }

      const particles = {
        items: [],

        spawn(x, y) {
          for (let i = 0; i < 5; i++) {
            this.items.push({
              x: x,
              y: y,
              vx: (Math.random() - 0.5) * 5,
              vy: (Math.random() - 0.5) * 5,
              life: 1.0,
              color: Math.random() > 0.5 ? "#fff" : "#fdd835",
            })
          }
        },

        draw() {
          for (let i = 0; i < this.items.length; i++) {
            let p = this.items[i]
            p.x += p.vx
            p.y += p.vy
            p.life -= 0.05

            ctx.globalAlpha = p.life
            ctx.fillStyle = p.color
            ctx.beginPath()
            ctx.arc(p.x, p.y, 3, 0, Math.PI * 2)
            ctx.fill()
            ctx.globalAlpha = 1.0

            if (p.life <= 0) {
              this.items.splice(i, 1)
              i--
            }
          }
        },
        reset() {
          this.items = []
        },
      }

      /**
       * MAIN LOOP
       */
      function loop() {
        // Clear
        ctx.clearRect(0, 0, canvas.width, canvas.height)

        // Update & Draw
        background.draw()

        // Pipes drawn before ground
        pipes.draw()

        // Ground on top of pipes
        ground.draw()

        // Bird and Effects on top
        bird.draw()
        particles.draw()

        // Increment frame
        if (gameState !== "GAMEOVER") {
          frames++
        }

        requestAnimationFrame(loop)
      }

      // Start Loop
      loop()
    </script>
  </body>
</html>
